# These are the core functions of the algorithm.
import numpy as np
from numba import jit
from numba.typed import List
import numba
import itertools
from pypuzzle3d.utils import rotations24, fingerprint, piece_to_unique_rotations_as_block_lists, itertools_product
from multiprocessing.pool import ThreadPool


def find_solutions(pieces, max_solutions=None):
    pieces_poses = [piece_to_unique_rotations_as_block_lists(piece) for piece in pieces]
    return explore(pieces_poses, max_solutions=max_solutions)


@jit(nopython=True, nogil=True)
def place(piece, world, location):
    # Note that we copy the input world representation so we don't modify it.
    world_copy = world.copy()
    for i in range(piece.shape[0]):
        world_copy[2+location[0]+piece[i][0],
                   2+location[1]+piece[i][1],
                   2+location[2]+piece[i][2]] += 1

    return world_copy


@jit(nopython=True, nogil=True)
def check(world):
    """ Check if a world representation w is valid:
         a) no figures overlap in space
         b) no figures are outside of the 3x3x3 cube
    """
    if np.sum(world > 1) == 0 and (np.sum(world)-np.sum(world[2:5, 2:5, 2:5])) == 0:
        return True
    else:
        return False


def explore(pieces, n_pieces=None, world=None, soFar=None, solutions=None, max_solutions=None, verbose=True):
    """
    Main function for the exploration of solutions. Recursivelly explores al posible combinations of positions
    and orientations of the pieces, pruning branches when a non-valid configuration is found. This exploits the fact
    that the order in which the figures are placed is irrelevant.

    Parameters
    ----------

    pieces:     list of pieces for the puzzle, where each piece has been generated by calling pieceGen()

    n_pieces:   No need to set this variable manually. Used in the recursive calls to know whether all pieces
                have been placed.

    world:      No need to set this variable manually. It is a 7x7x7 representation of the current state of the
                cube we are building (occupancy only). It is 7x7x7 to avoid exceptions when part of a piece is outside
                the 3x3x3 cube.

    soFar:      No need to set this variable manually. List of the figures we have placeed so far, alongside with their
                location. Each recursive call creates its own copy of this variable.

    solutions:  No need to set this variable manually. List of solutions found so far.

    """

    # Some variables are initialized by the first call to the function explore()
    # The conde inside these If's is executed only at the top call in the recursive tree
    assert len(pieces) > 1, "Solving a puzzle of 1 piece does not make much sense."
    if solutions is None:
        solutions = List.empty_list(numba.core.types.ListType(numba.core.types.Tuple([numba.types.int32[:, :],
                                                                                      numba.types.int32[:]])))
        if np.sum([piece.shape[1] for piece in pieces]) != 3**3:
            return []
    if soFar is None:
        soFar = List.empty_list(numba.core.types.Tuple([numba.types.int32[:, :], numba.types.int32[:]]))

    if world is None:
        world = np.zeros((7, 7, 7), np.int32)

    if n_pieces is None:
        n_pieces = len(pieces)

    pieces = List(pieces)
    # Generate all posible locations [(0,0,0), (0,0,1), ...]
    loc = np.asarray(list(itertools.product([0, 1, 2], [0, 1, 2], [0, 1, 2])), dtype=np.int32)

    first_level_branches_to_explore = []

    # For each orientation of the first piece in the list of pieces...
    for orient in pieces[0]:

        # For each posible location ...
        for l in loc:

            # We place the piece with the current orientation in the current location
            worldT = place(orient, world, l)

            # Then we evaluate the resulting representation of the world.
            # If no blocks are outside of the 3x3x3 cube and no pieces overlap...
            if check(worldT):
                soFarT = soFar.copy()
                soFarT.append((orient, l))
                first_level_branches_to_explore.append(
                    [pieces[1:].copy(), n_pieces, worldT.copy(), soFarT.copy(), solutions.copy(), max_solutions])

    with ThreadPool() as p:
        multiprocessing_results = p.imap_unordered(lambda x: explore_deep(*x), first_level_branches_to_explore)

        for solutions_from_brach in multiprocessing_results:
            if solutions_from_brach is None:
                return None
            for solution in solutions_from_brach:
                solutions.append(solution)

            solutions = findUnique(solutions)
            if verbose and len(solutions) > 0 and len(solutions_from_brach) > 0:
                print(f"Found {len(solution)} unique solutions.")
            if max_solutions is not None and len(solutions) > max_solutions:
                return None

    return solutions


@jit(nopython=True, nogil=True)
def explore_deep(pieces, n_pieces, world, soFar, solutions, max_solutions=None):

    locations = itertools_product((0, 1, 2), (0, 1, 2), (0, 1, 2))

    for orient in pieces[0]:
        for location in locations:

            worldT = place(orient, world, location)

            if check(worldT):
                if len(soFar) == (n_pieces-1):

                    soFarT = soFar.copy()
                    soFarT.append((orient, location))
                    solutions.append(soFarT)
                    solutions = findUnique(solutions)
                    n_solutions = len(solutions)

                    if max_solutions is not None and n_solutions > max_solutions:
                        return None

                else:
                    soFarT = soFar.copy()
                    soFarT.append((orient, location))

                    solutions = explore_deep(pieces[1:], n_pieces=n_pieces, world=worldT, soFar=soFarT,
                                             solutions=solutions, max_solutions=max_solutions)
                    if solutions is None:
                        return None

    return solutions


@jit(nopython=True, nogil=True)
def findUnique(solutions, verbose=False):
    """
    Takes a set of non-unique solutions to a 3x3x3 puzzle and returns a list of unique solutions. That is, given
    a solution, do not consider the 26 rotated versions of that cube as different solutions.

    The idea is simple: initialize a list with the first solution found. Then, for each non-unique solution, test if a
    rotated version of it is in the that list. If not, add it to the list.

    IMPORTANT NOTE: If the puzzle contains two identical pieces, this function will identify two solutions where the
    identical pieces are swaped as different. This can be modified altering the variable keys in function fingerprint()

    Parameters
    ----------

    solutions:  list of non-unique solutions as returned by explore()

    """

    if len(solutions) < 2:
        return solutions
    # initialize list of unique solutions
    unique_success = solutions.copy()[:1]

    # initialize a list with the fingerprints of unique solutions
    # in this context a fingerprint is a 3x3x3 matrix where each entry is an integer representing
    # the figure that occupies that region of space. Each figure/piece has a different integer identifier
    unique_finger = [fingerprint(solutions[0])]

    if verbose:
        print("Unique found... ")
        print(len(unique_success))

    i = 0
    # for each solution in the list of non-unique solutions...
    for suc in solutions[1:]:

        # generate the 24 rotated versions of one fingerprint of the solution
        rots = rotations24(fingerprint(suc))

        # by default, assume this solution is one we have not seen before
        unique_flag = True

        # if any of the rotated fingerprints of the solution is in our list of fingerprints,
        # the solution is not a new one. Mark the flag as false.
        for rot in rots:
            for uni in unique_finger:
                if np.all(rot == uni):
                    unique_flag = False

        # If none of the rotated versions of the solution is in our list of fingerprints, the solution
        # is indeed new. We add it to the list of unique solutions, and its fingerprint to the list of
        # fingerprints.
        if unique_flag:
            unique_finger.append(fingerprint(suc))
            unique_success.append(suc)
            if verbose:
                print("Unique found... ")
                print(len(unique_success))
        i += 1
    return unique_success
