# These are the core functions of the algorithm.
import numpy as np
from numba import jit
import itertools
from pypuzzle3d.utils import rotations24, fingerprint


@jit(nopython=True)
def place(piece, wo, location):
    """ Place a figure piece in the world representation wo at location l
        then return the resulting world representation
    """
    # Note that we copy the input world representation so we dont modify it.
    w = wo.copy()
    for i in range(piece.shape[0]):
        w[2 + location[0] + piece[i][0], 2 + location[1] + piece[i][1], 2 + location[2] + piece[i][2]] += 1

    return w


@jit(nopython=True)
def check(w):
    """ Check if a world representation w is valid:
         a) no figures overlap in space
         b) no figures are outside of the 3x3x3 cube
    """
    if np.sum(w > 1) == 0 and (np.sum(w) - np.sum(w[2:5, 2:5, 2:5])) == 0:
        return True
    else:
        return False


def explore(pieces, n_pieces=None, world=None, soFar=[], solutions=None, max_solutions=None, verbose=True):
    """
    Main function for the exploration of solutions. Recursivelly explores al posible combinations of positions
    and orientations of the pieces, pruning branches when a non-valid configuration is found. This exploits the fact
    that the order in which the figures are placed is irrelevant.

    Parameters
    ----------

    pieces:     list of pieces for the puzzle, where each piece has been generated by calling pieceGen()

    n_pieces:   No need to set this variable manually. Used in the recursive calls to know whether all pieces
                have been placed.

    world:      No need to set this variable manually. It is a 7x7x7 representation of the current state of the
                cube we are building (occupancy only). It is 7x7x7 to avoid exceptions when part of a piece is outside
                the 3x3x3 cube.

    soFar:      No need to set this variable manually. List of the figures we have placeed so far, alongside with their
                location. Each recursive call creates its own copy of this variable.

    solutions:  No need to set this variable manually. List of solutions found so far.

    """

    # Some variables are initialized by the first call to the function explore()
    # The conde inside these If's is executed only at the top call in the recursive tree

    if isinstance(solutions, type(None)):
        solutions = []
        if np.sum([piece.shape[1] for piece in pieces]) != 3**3:
            return []

    if isinstance(world, type(None)):
        world = np.zeros((7, 7, 7), np.int32)

    if isinstance(n_pieces, type(None)):
        n_pieces = len(pieces)

    # Generate all posible locations [(0,0,0), (0,0,1), ...]
    loc = np.asarray(list(itertools.product([0, 1, 2], [0, 1, 2], [0, 1, 2])), dtype=np.int32)

    # For each orientation of the first piece in the list of pieces...
    for orient in pieces[0]:

        # For each posible location ...
        for lentry in loc:

            # We place the piece with the current orientation in the current location
            worldT = place(orient, world, lentry)

            # Then we evaluate the resulting representation of the world.
            # If no blocks are outside of the 3x3x3 cube and no pieces overlap...
            if check(worldT):

                # If the piece we just placed was the last one, we have found a solution
                if len(soFar) == (n_pieces - 1):

                    # create a copy of the list of movements that took us here
                    soFarT = list(soFar)

                    # add the last movement we made, which completed the solution
                    soFarT.append([orient, lentry])

                    # add the solution we just found to the list of solutions... and keep searching
                    solutions.append(soFarT)
                    solutions = findUnique(solutions)
                    if verbose:
                        print("Solution %d found." % (len(solutions)))
                    if max_solutions is not None and len(solutions) > max_solutions:
                        if verbose:
                            print("Max_solutions exceeded. Aborting search.")
                        return None

                # If the piece we just placed is not the last one...
                else:
                    # Create a copy of the list of movements we have made (so recursive calls do not modify our copy)
                    soFarT = list(soFar)

                    # add the last movement we made
                    soFarT.append([orient, lentry])

                    # recursivelly cal explore(), setting pieces=pieces[1:], so the recursive call only has to place
                    # the remaining pieces to finish the puzzle. This limits the depth of the recursive tree to the
                    # number of pieces in the puzzle
                    solutions = explore(pieces[1:], n_pieces=n_pieces, world=worldT, soFar=soFarT,
                                        solutions=solutions, max_solutions=max_solutions)

                    if solutions is None:
                        return None

    # Note that, if a particular orientation of a piece cant be placed successfully, we do not explore that branch
    # in the tree of possible combinations, so we are effectively pruning this tree, making things faster.
    # This is much faster that the naive brute force approach of testing all posible piece-orientation-location
    # combinations looking for solutions. Another trick to speed things up is the fact that the function figureGen()
    # removes orientations that are equivalent for pieces with symmetry, so not all pieces have 26
    # different orientations.

    # finally, return all solutions found
    return solutions


def findUnique(solutions, verbose=False):
    """
    Takes a set of non-unique solutions to a 3x3x3 puzzle and returns a list of unique solutions. That is, given
    a solution, do not consider the 26 rotated versions of that cube as different solutions.

    The idea is simple: initialize a list with the first solution found. Then, for each non-unique solution, test if
    a rotated version of it is in the that list. If not, add it to the list.

    IMPORTANT NOTE: If the puzzle contains two identical pieces, this function will identify two solutions where the
    identical pieces are swaped as different. This can be modified altering the variable keys in function fingerprint()

    Parameters
    ----------

    solutions:  list of non-unique solutions as returned by explore()

    """

    # initialize list of unique solutions
    unique_success = [solutions[0]]

    # initialize a list with the fingerprints of unique solutions
    # in this context a fingerprint is a 3x3x3 matrix where each entry is an integer representing
    # the figure that occupies that region of space. Each figure/piece has a different integer identifier
    unique_finger = [fingerprint(solutions[0])]

    if verbose:
        print("Unique found... (%d)." % (len(unique_success)))

    i = 0
    # for each solution in the list of non-unique solutions...
    for suc in solutions[1:]:

        # generate the 24 rotated versions of one fingerprint of the solution
        rots = rotations24(fingerprint(suc))

        # by default, assume this solution is one we have not seen before
        unique_flag = True

        # if any of the rotated fingerprints of the solution is in our list of fingerprints,
        # the solution is not a new one. Mark the flag as false.
        for rot in rots:
            for uni in unique_finger:
                if np.all(rot == uni):
                    unique_flag = False

        if verbose and i % 100 == 0:
            print("Progress: %.2f%%" % (100 * i / float(len(solutions))))

        # If none of the rotated versions of the solution is in our list of fingerprints, the solution
        # is indeed new. We add it to the list of unique solutions, and its fingerprint to the list of
        # fingerprints.
        if unique_flag:
            unique_finger.append(fingerprint(suc))
            unique_success.append(suc)
            if verbose:
                print("Unique found... (%d)." % (len(unique_success)))

        i += 1

    return unique_success
