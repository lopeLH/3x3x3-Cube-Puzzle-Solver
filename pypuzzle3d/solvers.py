# These are the core functions of the algorithm.
import numpy as np
import matplotlib.pyplot as plt
import glob
from numba import jit


@jit(nopython=True)
def place(p, wo, l):
    """ Place a figure p in the world representation wo at location l
        then return the resulting world representation
    """
    # Note that we copy the input world representation so we dont modify it.
    w = wo.copy()
    for i in range(p.shape[0]):
        w[2+l[0]+p[i][0], 2+l[1]+p[i][1], 2+l[2]+p[i][2]] += 1

    return w


@jit(nopython=True)
def check(w):
    """ Check if a world representation w is valid:
         a) no figures overlap in space
         b) no figures are outside of the 3x3x3 cube
    """
    if np.sum(w>1) == 0 and (np.sum(w)-np.sum(w[2:5, 2:5,2:5])) == 0:
        return True
    else:
        return False


def explore(pieces, n_pieces=None, world=None, soFar=[], solutions=None, max_solutions=None, verbose=True):
    """
    Main function for the exploration of solutions. Recursivelly explores al posible combinations of positions
    and orientations of the pieces, pruning branches when a non-valid configuration is found. This exploits the fact
    that the order in which the figures are placed is irrelevant.

    Parameters
    ----------
    pieces:     list of pieces for the puzzle, where each piece has been generated by calling pieceGen()
    n_pieces:   No need to set this variable manually. Used in the recursive calls to know whether all pieces
                have been placed.
    world:      No need to set this variable manually. It is a 7x7x7 representation of the current state of the
                cube we are building (occupancy only). It is 7x7x7 to avoid exceptions when part of a piece is outside
                the 3x3x3 cube.
    soFar:      No need to set this variable manually. List of the figures we have placeed so far, alongside with their
                location. Each recursive call creates its own copy of this variable.
    solutions:  No need to set this variable manually. List of solutions found so far. 
    """

    # Some variables are initialized by the first call to the function explore() 
    # The conde inside these If's is executed only at the top call in the recursive tree 
    if type(solutions) == type(None):
        solutions = []
        if np.sum([piece.shape[1] for piece in pieces]) != 3**3:
            return []

    if type(world) == type(None):
        world = np.zeros((7,7,7), np.int32)

    if type(n_pieces) == type(None):
        n_pieces = len(pieces)

    # Generate all posible locations [(0,0,0), (0,0,1), ...]
    loc = np.asarray(list(itertools.product([0,1,2],[0,1,2],[0,1,2])), dtype=np.int32)

    # For each orientation of the first piece in the list of pieces...
    for orient in pieces[0]:
        # For each posible location ...
        for l in loc:
            #We place the piece with the current orientation in the current location
            worldT = place(orient, world, l)

            #Then we evaluate the resulting representation of the world.
            # If no blocks are outside of the 3x3x3 cube and no pieces overlap...
            if check(worldT):
                soFarT = list(soFar)
                soFarT.append([orient, l])

                plti = int(sorted(glob.glob("gif/*.png"), reverse=True)[0].split("/")[1].split(".")[0])+1
                drawState(soFarT, i=plti)
                plt.savefig(f"gif/{plti:05d}.png")

                # If the piece we just placed was the last one, we have found a solution
                if len(soFar) == (n_pieces-1):
                    # add the solution we just found to the list of solutions... and keep searching
                    solutions.append(soFarT)
                    solutions = findUnique(solutions)

                    if verbose:
                        print("Solution %d found." % (len(solutions)))
                    if max_solutions is not None and len(solutions) > max_solutions:
                        if verbose:
                            print("Max_solutions exceeded. Aborting search.")
                        return None

                # If the piece we just placed is not the last one...
                else:
                    # recursivelly cal explore(), setting pieces=pieces[1:], so the recursive call only has to place
                    # the remaining pieces to finish the puzzle. This limits the depth of the recursive tree to the
                    # number of pieces in the puzzle
                    solutions = explore(pieces[1:], n_pieces=n_pieces, world=worldT, soFar=soFarT,
                                        solutions=solutions, max_solutions=max_solutions)

                    if solutions is None:
                        return None

    # Note that, if a particular orientation of a piece cant be placed succesfully, we do not explore that branch
    # in the tree of posible combinations, so we are effectivelly pruning this tree, making things faster.
    # This is much faster that the naive brute force approach of testing all posible piece-orientation-location
    # combinations looking for solutions. Another trick to speed things up is the fact that the function figureGen()
    # removes orientations that are equivalent for pieces with simetry, so not all pieces have 26
    # different orientations.

    # finally, return all solutions found
    return solutions
